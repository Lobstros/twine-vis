<!doctype html>
<html>
  <head>
    <style>
      /*html, body, #twine-graph {height: 100%; width:100%;margin:0;padding:0;}*/
      body { background-color: black; font-size: 0.8rem; }
      .links line {stroke: #aaa;}
      .links line.highlighted {stroke: #f00;}
      .nodes rect {fill: black; stroke: #aaa; stroke-width: 3px;}
      .nodes div {color: white;}
    </style>
  </head>
  <body>
    <svg id="twine-graph" xmlns:xhtml="http://www.w3.org/1999/xhtml"></svg>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>
      const TWINE_FILE_PATH = "Quack of Duckness.html";
      const TWINE_PASSAGEDATA_LITERAL_LINK_REGEX = /\[\[(?<target>[A-Za-z0-9 _]+)\]\]/g;
      const TWINE_PASSAGEDATA_RIGHT_LINK_REGEX = /\[\[(?<value>[A-Za-z0-9 _]+)->(?<target>[A-Za-z0-9 _]+)\]\]/g;
      const TWINE_PASSAGEDATA_LEFT_LINK_REGEX = /\[\[(?<target>[A-Za-z0-9 _]+)<-(?<value>[A-Za-z0-9 _]+)\]\]/g;
      const NODE_WIDTH = 192;
      const NODE_HEIGHT = 144;
      const parser = new DOMParser();

      let dragging = false;
      document.getElementById("twine-graph").addEventListener( "mousedown", e => dragging=true )

      const svg = d3.select("svg");

      function loadVis(twineDoc) {
        const storyData = twineDoc.getElementsByTagName("tw-storydata")[0];
        // Make "node" objects from XML file
        const nodes = Array.from(storyData.getElementsByTagName("tw-passagedata")).map(elem => passageDataElemToObj(elem));

        // Create a handy map of nodes from node names for fast lookup.
        const nodeMapByName = new Map();
        nodes.forEach( node => nodeMapByName.set(node.id, node) );

        // Links between nodes are currently children of "from" nodes themselves.
        // We need to grab them into a separate array to pass to d3.
        let links = [];
        nodes.forEach( node => links.push(...node.links));
        console.log(links);

        // Link nodes up
        links.forEach( link => { link.sourceNode = nodeMapByName.get(link.source); link.targetNode = nodeMapByName.get(link.target); } )

        //We need to work out where to plot each node by link depth from the start
        annotateNodesByDepth(nodes);

        const link = svg.append("g").attr("class", "links").selectAll("line").data(links).join(linkEnter);
        const node = svg.append("g").attr("class", "nodes").selectAll("circle").data(nodes).join(nodeEnter)
                        .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

        function linkEnter(enter) {
          return enter.append("line").attr("id", d=>"link-"+d.sourceNode.pid+"-"+d.targetNode.pid)
                                     .attr("x1", d=>d.sourceNode.x + clamp(d.targetNode.x+d.targetNode.width/2, d.sourceNode.x, d.sourceNode.width))
                                     .attr("y1", d=>d.sourceNode.y)
                                     .attr("x2", d=>d.targetNode.x + clamp(d.sourceNode.x+d.sourceNode.width/2, d.targetNode.x, d.targetNode.width))
                                     .attr("y2", d=>d.targetNode.y);
        }

        function nodeEnter(enter) {
          const nodeGroup = enter.append("g").attr("transform", d => `translate(${d.x},${d.y})`);
          nodeGroup.append("rect").attr("width", d=>d.width).attr("height", d=>d.height);
          nodeGroup.append("foreignObject").attr("width", d=>d.width).attr("height", d=>d.height)
                   .append("xhtml:div").attr("xmlns", "http://www.w3.org/1999/xhtml").text(d=>d.id + "\n" + d.text.substring(0,100));
          nodeGroup.on("mouseover", (ev, d) => downstreamHighlight(d, true) )
                   .on("mouseout", (ev, d) => downstreamHighlight(d, false) );
          return nodeGroup;
        }

        function nodeUpdate(update) {
               update.select("g").transition().duration(ANIMATION_DURATION_MS).ease(ANIMATION_EASING)
                      .attr("visibility", d => d.isBelowHighestCollapsed() ? "hidden" : "visible")
               .attr("class", nodeClass)
               .attr("x", nodeXPos)
               .attr("y", d=>SYMBOL_HALFHEIGHT*(d.top()))
               .attr("height", d=>SYMBOL_HALFHEIGHT*(d.height()));
        }

        const width = Math.max(...nodes.map(node => node.x+node.width))
        console.log(width)
        svg.style("width", Math.max(...nodes.map(node => node.x+node.width))+'px');
        svg.style("height", Math.max(...nodes.map(node => node.y+node.height))+'px');
      }

      function downstreamHighlight(d, highlightState) {
        if (d.links.length === 0) return;
        //const highlightLinks = new Set();
        //let currentLink = d.links[0];
        //do {
        //  highlightLinks.add(currentLink);
        //} while ( (currentLink.targetNode.links.length > 0) && (currentLink = currentLink.targetNode.links[0]) );
        const highlightLinks = new DownstreamPath(d).getPath();
        console.log(highlightLinks);
        if (highlightState === true) {
          highlightLinks.forEach(link => document.getElementById("link-" + link.sourceNode.pid + "-" + link.targetNode.pid).classList.add("highlighted"));
        } else {
          highlightLinks.forEach(link => document.getElementById("link-" + link.sourceNode.pid + "-" + link.targetNode.pid).classList.remove("highlighted"));
        }
      }

      class DownstreamPath {
        constructor(rootNode) {
          this.linkPath = this.calcPath(rootNode);
        }
        calcPath(rootNode) {
          this.linkPath = [];
          let currentLink = rootNode.links[0];
          const NEXT_INDEX = 0;
          do {
            this.linkPath.push(currentLink);
          } while ( (currentLink.targetNode.links.length > 0) && (currentLink = currentLink.targetNode.links[NEXT_INDEX]) );
          return this.linkPath;
        }
        getPath() {
          return this.linkPath;
        }
        switchLinkLeft(linkDepth) {
          // Get node one along in parents child array at requested depth
          const oldNode = this.linkPath[linkDepth];
          const oldNodeParent = this.linkPath[linkDepth-1];
          const oldNodeIdx = oldNodeParent.links.findIndex(oldNode);
          const newNode = oldNodeParent.links[oldNodeIdx + 1 % oldNodeParent.links.length];
          // Slice off everything below old node's parent
          this.linkPath = this.linkPath.slice(0, linkDepth);
          // Stick on new calculated tree
          this.linkPath = this.linkPath.concat(this.getPath(newNode));
        }
        switchLinkRight(linkDepth) {

        }
      }

      function passageDataElemToObj(elem) {
        const xyPositions = elem.getAttribute("position").split(",", 2);
        const xySizes = elem.getAttribute("size").split(",", 2);
        const node = {
          "pid": elem.getAttribute("pid"),
          "id": elem.getAttribute("name"),  // CONFUSION WARNING. Only called "id" for compatibility with d3-force!
          "text": elem.innerText,
          "x": parseInt(xyPositions[0]),
          "y": parseInt(xyPositions[1]),
          "width": parseInt(xySizes[0]),
          "height": parseInt(xySizes[0]),
        }
        node.links = passageDataElemToLinks(node)
        return node;
      }

      function passageDataElemToLinks(node) {
        let links = [];
        const literalLinkMatches = Array.from(node.text.matchAll(TWINE_PASSAGEDATA_LITERAL_LINK_REGEX));
        const rightLinkMatches = Array.from(node.text.matchAll(TWINE_PASSAGEDATA_RIGHT_LINK_REGEX));
        const leftLinkMatches = Array.from(node.text.matchAll(TWINE_PASSAGEDATA_LEFT_LINK_REGEX));
        links.push(
                ...literalLinkMatches.map( match => ({"target": match.groups.target, "value": match.groups.target, "source":node.id}) ),
                ...rightLinkMatches.map( match => ({"target": match.groups.target, "value": match.groups.value, "source":node.id}) ),
                ...leftLinkMatches.map( match => ({"target": match.groups.target, "value": match.groups.value, "source":node.id}) )
        );
        return links;
      }

      function annotateNodesByDepth(nodes) {
        const firstNode = nodes[0];
        const recurseAnnotate = (node, currentDepth) => {
          if (node.depth!==undefined) return;
          node.depth = currentDepth;
          if(node.links===undefined) return;
          node.links.forEach(link => recurseAnnotate(link.targetNode, currentDepth+1));
        };
        firstNode.depth = 0;
        firstNode.links.forEach(link => recurseAnnotate(link.targetNode, 1));
      }

      function dragstarted(ev, d) { if (!ev.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
      function dragged(ev, d) { d.fx = ev.x; d.fy = ev.y; }
      function dragended(ev, d) { if (!ev.active) simulation.alphaTarget(0.0001); d.fx = null; d.fy = null; }

      function createSvgForeignTextObject(text) {

      }
      fetch(TWINE_FILE_PATH).then(response => response.text()).then(textData => loadVis(parser.parseFromString(textData,"text/html")));
      function clamp(val, max, min) {
        return Math.min(Math.max(val,max),min);
      }
    </script>
  </body>
</html>