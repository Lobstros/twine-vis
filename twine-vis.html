<!doctype html>
<html>
  <head>
    <title>Twine story visualiser</title>
    <style>
      /*html, body, #twine-graph {height: 100%; width:100%;margin:0;padding:0;}*/
      body { background-color: black; font-size: 1rem; font-family: sans-serif; color: white; }
      .links line {stroke: #aaa;}
      .links line.highlighted {stroke: #f00;}
      .nodes rect { fill: black; stroke: #aaa; stroke-width: 3px; }
    </style>
  </head>
  <body>
    <fieldset>
        <legend>Open story file</legend>
        <input type="file" id="twine-file-input" accept="text/html"><br>
    </fieldset>
    <svg id="twine-graph" xmlns:xhtml="http://www.w3.org/1999/xhtml"></svg>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>
      const TWINE_PASSAGEDATA_LINK_REGEX = /\[\[(.+?)\]\]/g;
      const NODE_WIDTH = 128;
      const NODE_HEIGHT = 64;
      const ANIMATION_DURATION_MS = 500;
      const ANIMATION_EASING = d3.easeQuadInOut;
      const NAV_SYMBOL_SIZE = 20;

      const DISPLAY_MODES = Object.freeze({
        allNodes:   Symbol("allNodes"),
        linear:  Symbol("linear")
      });
      let currentDisplayMode = DISPLAY_MODES.allNodes;

      class StoryNode {

        constructor(htmlElem) {
          const xyPositions = htmlElem.getAttribute("position").split(",", 2);
          const xySizes = htmlElem.getAttribute("size").split(",", 2);
          this.pid = htmlElem.getAttribute("pid");
          this.id = htmlElem.getAttribute("name");  // CONFUSION WARNING. Only called "id" for compatibility with d3-force!
          this.text = htmlElem.innerText;
          this.x = parseInt(xyPositions[0]);
          this.y = parseInt(xyPositions[1]);
          this.width = parseInt(xySizes[0]);
          this.height = parseInt(xySizes[0]);
          this.links = StoryLink.parseFromText(this.text, this.id);
        }

      }

      class StoryLink {

        constructor(source, target, descText) {
          this.source = source;
          this.target = target;
          this.value = descText;
        }

        static parseFromText(text, source_id) {
          let linkComponents;
          const linkTexts = Array.from(text.matchAll(TWINE_PASSAGEDATA_LINK_REGEX)).map(res => res[1]);  // Return first group (link text) only
          links = linkTexts.map( linkText => {
            linkComponents = linkText.split("->");
            if (linkComponents.length > 1) return new StoryLink(source_id, linkComponents[1], linkComponents[0]);
            linkComponents = linkText.split("<-");
            if (linkComponents.length > 1) return new StoryLink(source_id, linkComponents[0], linkComponents[1]);
            // Fallthrough: it's a link without a '->' operator, so link target and text description are the same.
            return new StoryLink(source_id, linkText, linkText);
          })
          return links;
        }

      }

      class StoryPath {
        // Wraps an ordered list of Links that define a legal path through StoryNodes,
        // with helper functions to shift any of these links to neighbours that the reculculates a valid path below it.
        //TODO: Intelligently handle loops
        constructor(rootNode) {
          this.linkPath = rootNode ? this.calcPath(rootNode) : [];
        }

        calcPath(rootNode) {
          let linkPath = [];
          if (rootNode.links.length === 0) return linkPath;
          let currentLink = rootNode.links[0];
          const NEXT_INDEX = 0;
          do {
            linkPath.push(currentLink);
            if (linkPath.includes(currentLink)) break;  // TODO: Less terrible loop protection
          } while ( (currentLink.targetNode.links.length > 0) && (currentLink = currentLink.targetNode.links[NEXT_INDEX]) );
          return linkPath;
        }

        getPath() {
          return this.linkPath;
        }

        getHeadNode() {
          return this.linkPath.length > 0 ? this.linkPath[0].sourceNode : null;
        }

        getLinksAtDepth(depth) {
          if (depth<0) return [];
          const parentNode = this.linkPath[depth].sourceNode;
          return parentNode.links;
        }

        swapToAdjacentLink(nodeObj, distance) {
          // We're passed a node that the user wants to switcheroo for an adjacent one.
          // We need to find the index of the link in our array that corresponds to the one linking it to its parent.
          const linkDepth = this.linkPath.findIndex( link => link.targetNode === nodeObj );
          const linkToShift = this.linkPath[linkDepth];
          const parentNode = linkToShift.sourceNode;
          const oldLinkIdx = parentNode.links.indexOf(linkToShift);
          const numLinks = parentNode.links.length;
          const newLinkIdx = (oldLinkIdx + distance + numLinks) % numLinks;
          // Get link one along in parents child array at requested depth
          const newLink = parentNode.links[newLinkIdx];
          // Slice off everything below old node's parent
          this.linkPath = this.linkPath.slice(0, linkDepth);
          // Stick on new calculated tree
          this.linkPath.push(newLink);
          this.linkPath = this.linkPath.concat(this.calcPath(newLink.targetNode));
        }

        containsNode(nodeObj) {
          return [this.linkPath[0].sourceNode].concat(this.linkPath.map(link => link.targetNode)).includes(nodeObj);
        }

        getNodeDepth(nodeObj) {
          // Nodes take the depth of the link they are a parent of, or 1 + the previous if at the end of the path.
          const pathLength = this.linkPath.length;
          if (pathLength === 0) return 0;
          if (nodeObj === this.linkPath[pathLength-1].targetNode) return pathLength;
          return this.linkPath.findIndex( link => link.sourceNode === nodeObj );
        }

      }

      const parser = new DOMParser();
      const svg = d3.select("svg");
      const defs = svg.append("defs")
      defs.append("path").attr("id", "leftarrow").attr("fill", "darkred").attr("d", `M 0,${NAV_SYMBOL_SIZE/2} ${NAV_SYMBOL_SIZE},0 ${NAV_SYMBOL_SIZE},${NAV_SYMBOL_SIZE} Z`)
      defs.append("path").attr("id", "rightarrow").attr("fill", "darkred").attr("d", `M 0,0 0,${NAV_SYMBOL_SIZE} ${NAV_SYMBOL_SIZE},${NAV_SYMBOL_SIZE/2} Z`)
      const linksG = svg.append("g").attr("class", "links");
      const nodesG = svg.append("g").attr("class", "nodes");  // Put nodes after links in SVG so they render on top
      let highlightedPath = new StoryPath();
      let links;
      let nodes;

      function loadVis(twineDoc) {
        const storyData = twineDoc.getElementsByTagName("tw-storydata")[0];
        // Make "node" objects from XML file
        nodes = Array.from(storyData.getElementsByTagName("tw-passagedata")).map(elem => new StoryNode(elem));

        // Create a handy map of nodes from node names for fast lookup.
        const nodeMapByName = new Map();
        nodes.forEach( node => nodeMapByName.set(node.id, node) );

        // Links between nodes are currently children of "from" nodes themselves.
        // We need to grab them into a separate array to pass to d3.
        links = [];
        nodes.forEach( node => links.push(...node.links));

        // Link nodes up
        links.forEach( link => { link.sourceNode = nodeMapByName.get(link.source); link.targetNode = nodeMapByName.get(link.target); } )

        //We need to work out where to plot each node by link depth from the start
        annotateNodesByDepth(nodes);

        const width = Math.max(...nodes.map(node => node.x+node.width))
        svg.style("width", Math.max(...nodes.map(node => node.x+node.width))+'px');
        svg.style("height", Math.max(...nodes.map(node => node.y+node.height))+'px');

        drawNetwork();
      }

      function drawNetwork() {
        const link = linksG.selectAll("line").data(links).join(linkEnter, linkUpdate);
        const node = nodesG.selectAll("g.node").data(nodes, d=>d.pid).join(nodeEnter, nodeUpdate)
                           .sort(d=>nodeVisibility(d));  // Put visible nodes at the end, so they show on top.
      }

      function linkEnter(enter) {
        const linkLine = enter.append("line")
        linkLine.attr("id", d=>"link-"+d.sourceNode.pid+"-"+d.targetNode.pid)
        linkUpdate(linkLine);
      }

      function linkUpdate(update) {
        update.transition().duration(ANIMATION_DURATION_MS).ease(ANIMATION_EASING)
              //.attr("x1", d=>d.sourceNode.x + clamp(d.targetNode.x+d.targetNode.width/2, d.sourceNode.x, d.sourceNode.width))
              //.attr("y1", d=>d.sourceNode.y)
              //.attr("x2", d=>d.targetNode.x + clamp(d.sourceNode.x+d.sourceNode.width/2, d.targetNode.x, d.targetNode.width))
              //.attr("y2", d=>d.targetNode.y);
              .attr("x1", d=>nodeX(d.sourceNode) + d.sourceNode.width/2)
              .attr("y1", d=>nodeY(d.sourceNode) + d.sourceNode.height/2)
              .attr("x2", d=>nodeX(d.targetNode) + d.targetNode.width/2)
              .attr("y2", d=>nodeY(d.targetNode) + d.targetNode.height/2)
              .attr("visibility", currentDisplayMode === DISPLAY_MODES.allNodes ? "visible" : "hidden");
      }

      function nodeEnter(enter) {
        const nodeGroup = enter.append("g").attr("class", "node");
        nodeGroup.append("rect").attr("width", NODE_WIDTH).attr("height", NODE_HEIGHT);
        nodeGroup.append("foreignObject").attr("width", d=>d.width).attr("height", d=>d.height)
                 .append("xhtml:div").attr("xmlns", "http://www.w3.org/1999/xhtml").text(d=>d.id).on("click", (ev, d) => toggleLinearDisplay(d));
        const pathControls = nodeGroup.append("g").attr("class", "path-controls").attr("transform", "translate(0,-15)");
        pathControls.append("use").attr("xlink:href", "#leftarrow").on("click", (ev, d) => {ev.stopPropagation(); shiftLinearPath(d, -1)})
        pathControls.append("use").attr("xlink:href", "#rightarrow").attr("x", 100-NAV_SYMBOL_SIZE).on("click", (ev, d) => {ev.stopPropagation(); shiftLinearPath(d, 1)})
        nodeUpdate(nodeGroup);
        return nodeGroup;
      }

      function nodeUpdate(update) {
        update.transition().duration(ANIMATION_DURATION_MS).ease(ANIMATION_EASING)
               .style("opacity", d => nodeVisibility(d) ? 1 : 0.12)
               .attr("transform", d => `translate(${nodeX(d)},${nodeY(d)})`);
        update.select("g.path-controls")
               .attr("opacity", d => currentDisplayMode === DISPLAY_MODES.linear && nodeVisibility(d) && highlightedPath.getLinksAtDepth(highlightedPath.getNodeDepth(d)-1).length > 1 ? 1 : 0);
        return update;
      }

      function toggleLinearDisplay(d) {
        highlight(highlightedPath, false);
        if (currentDisplayMode === DISPLAY_MODES.linear && d === highlightedPath.getHeadNode()) {
          currentDisplayMode=DISPLAY_MODES.allNodes;
          drawNetwork();
          return;
        }
        highlightedPath = new StoryPath(d);
        if (highlightedPath.getPath().length > 0) {  // Deny zero-length paths (they don't calc/render properly)
          currentDisplayMode = DISPLAY_MODES.linear;
        } else {
          currentDisplayMode = DISPLAY_MODES.allNodes;
        }
        highlight(highlightedPath, true);
        drawNetwork();
      }

      function shiftLinearPath(d, distance) {
        highlight(highlightedPath, false);
        highlightedPath.swapToAdjacentLink(d, distance);
        //highlight(highlightedPath, true);
        drawNetwork();
      }

      function nodeX(d){
        if (currentDisplayMode === DISPLAY_MODES.allNodes) {
          return d.x
        } else {
          return highlightedPath.containsNode(d) ? highlightedPath.getHeadNode().x : d.x;
        }
      }

      function nodeY(d) {
        if (currentDisplayMode === DISPLAY_MODES.allNodes) {
          return d.y
        } else {
          return highlightedPath.containsNode(d) ? highlightedPath.getHeadNode().y + 120*highlightedPath.getNodeDepth(d) : d.y;  // d.y if it'll be hidden anyway
        }
      }

      function nodeVisibility(d) {
        if (currentDisplayMode === DISPLAY_MODES.allNodes) {
          return true;
        } else {
          return highlightedPath.containsNode(d);
        }
      }

      function highlight(path, highlightState) {
        if (!path) return;
        const highlightLinks = path.getPath();
        if (highlightState === true) {
          highlightLinks.forEach(link => document.getElementById("link-" + link.sourceNode.pid + "-" + link.targetNode.pid).classList.add("highlighted"));
        } else {
          highlightLinks.forEach(link => document.getElementById("link-" + link.sourceNode.pid + "-" + link.targetNode.pid).classList.remove("highlighted"));
        }
      }

      function annotateNodesByDepth(nodes) {
        const firstNode = nodes[0];
        const recurseAnnotate = (node, currentDepth) => {
          if (node.depth!==undefined) return;
          node.depth = currentDepth;
          if(node.links===undefined) return;
          node.links.forEach(link => recurseAnnotate(link.targetNode, currentDepth+1));
        };
        firstNode.depth = 0;
        firstNode.links.forEach(link => recurseAnnotate(link.targetNode, 1));
      }

      //let dragging = false;
      //document.getElementById("twine-graph").addEventListener( "mousedown", e => dragging=true )
      //function dragstarted(ev, d) { if (!ev.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
      //function dragged(ev, d) { d.fx = ev.x; d.fy = ev.y; }
      //function dragended(ev, d) { if (!ev.active) simulation.alphaTarget(0.0001); d.fx = null; d.fy = null; }

      // Hardcoded file load for testing purposes.
      //fetch(TWINE_FILE_PATH).then(response => response.text()).then(textData => loadVis(parser.parseFromString(textData,"text/html")));

      function clamp(val, max, min) {
        return Math.min(Math.max(val,max),min);
      }

  document.getElementById("twine-file-input").addEventListener("change", readTwineFile);
  function readTwineFile() {
    const reader = new FileReader();
    const file = document.getElementById("twine-file-input").files[0];
    if (file) {
      reader.readAsText(file);
    }
    reader.addEventListener("load", function (ev) {loadVis(parser.parseFromString(ev.target.result,"text/html"))});
  }

    </script>
  </body>
</html>
